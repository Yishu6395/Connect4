Yishu Raj (2020CS50451), Sahil Shahare(2020CS50440)

We have first defined some basic functions, namely apply_changes and revert_changes. The apply_changes function keeps a track of the board state for the expectimax and minimax tree nodes, and the revert_changes just reverses the moves taken so that the board state is the initial state, from where the player shall take its further move. Then, we have our evaluation function, which returns a value containing some weight of the players scores and their pop out moves. For more details for this function, please refer to the code. 
Now, we have defined two helper recursive functions named exp_expectimax and max_expectimax. Imagine a tree with multiple children; the max_expectimax returns the child node with the maximum value and the exp_expectimax returns a value with the average of all the values of its children. The only difference here is that we have not designed a tree data structure, else we have simply covered it through recursion. So, basically we apply the max_expectimax function at the beginning and then recursively apply the exp_expectimax function for consequent recursions up to a certain depth which we shall fix in the expectimax function according to the time and the length of the legal actions possible. For more number of legal actions and less time, we have a relatively lower depth as compared to those with higher time and less number of legal actions. Since, this is played against a bot with some random move, therefore, we can say that given the array of legal moves, all the moves can be played by the bot with equal probability. Hence, we take the average of all and return the max or the best of all among them and this shall assure that our designed function shall beat the random move bot.
Now, for part b, we have two main helper functions named, min_intelligent and max_intelligent which returns respectively the minimum and the maximum of the subsequent tree node values. Both these functions take a board state, a count, alpha and beta as input and returns either the opposite function (one of the two) or a move (when count becomes 0). So, basically our idea is to apply the alpha beta pruning method via recursion and the count here refers to the maximum depth up to which the recursion shall go, and this depth depends on the time and the number of valid legal actions possible. Thus, we have our get_intelligent_move function, which simply sets the depth and returns a move based on the pruning method. 
